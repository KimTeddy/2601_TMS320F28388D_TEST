/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "F2838x" --part "F2838x_337bga" --package "337bga" --context "CPU1" --product "C2000WARE@6.00.01.00"
 * @v2CliArgs --device "TMS320F28388D" --package "337bga" --context "CPU1" --product "C2000WARE@6.00.01.00"
 * @versions {"tool":"1.26.0+4407"}
 */

/**
 * Import the modules used in this configuration.
 */
const led   = scripting.addModule("/driverlib/board_components/led", {}, false);
const led1  = led.addInstance();
const led2  = led.addInstance();
const led3  = led.addInstance();
const led4  = led.addInstance();
const epwm  = scripting.addModule("/driverlib/epwm.js", {}, false);
const epwm1 = epwm.addInstance();
const epwm2 = epwm.addInstance();
const epwm3 = epwm.addInstance();

/**
 * Write custom configuration values to the imported modules.
 */
led1.$name                = "myBoardLED0";
led1.gpio.$name           = "LED1_61";
led1.gpio.gpioPin.$assign = "GPIO61";

led2.$name                = "myBoardLED1";
led2.gpio.$name           = "LED2_62";
led2.gpio.gpioPin.$assign = "GPIO62";

led3.$name                = "myBoardLED2";
led3.gpio.$name           = "LED3_145";
led3.gpio.gpioPin.$assign = "GPIO145";

led4.$name                = "myBoardLED3";
led4.gpio.$name           = "LED4_146";
led4.gpio.gpioPin.$assign = "GPIO146";

const divider3       = system.clockTree["AUX_REFDIV"];
divider3.divideValue = 1;

const divider10       = system.clockTree["EPWMCLKDIV"];
divider10.divideValue = 1;

const multiplier2         = system.clockTree["PLL_IMULT"];
multiplier2.multiplyValue = 80;

const mux1       = system.clockTree["AUXOSCCLKSRCSEL"];
mux1.inputSelect = "INTOSC2";

const mux15       = system.clockTree["OSCCLKSRCSEL"];
mux15.inputSelect = "INTOSC2";

const default_warning = scripting.addModule("/driverlib/default_warning.js", {}, false);
scripting.suppress("Add the \'Device Support\' module in order to use Clock Tree tool and generate device support files\\. This suggestion can be ignored if not using the Clock Tree tool\\.", default_warning);

epwm1.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_ZERO      = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_ZERO      = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_UP_CMPB   = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_DOWN_CMPB = "EPWM_AQ_OUTPUT_LOW";
epwm1.$name                                                      = "EPWM1_U";
epwm1.epwmTimebase_emulationMode                                 = "EPWM_EMULATION_FREE_RUN";
epwm1.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm1.epwmTimebase_periodLoadMode                                = "EPWM_PERIOD_DIRECT_LOAD";
epwm1.epwmCounterCompare_enableShadowLoadModeCMPB                = false;
epwm1.epwmCounterCompare_enableShadowLoadModeCMPC                = false;
epwm1.epwmCounterCompare_enableShadowLoadModeCMPD                = false;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode            = true;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmDeadband_enableRED                                     = true;
epwm1.epwmDeadband_enableFED                                     = true;
epwm1.epwmDeadband_delayRED                                      = 60;
epwm1.epwmDeadband_delayFED                                      = 60;
epwm1.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm1.epwmTimebase_period                                        = 625;
epwm1.epwmTimebase_syncOutPulseMode                              = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO"];
epwm1.epwm.$assign                                               = "EPWM1";
epwm1.epwm.epwm_aPin.$assign                                     = "GPIO0";
epwm1.epwm.epwm_bPin.$assign                                     = "GPIO1";
scripting.suppress("It is recommended to use a non-zero counter compare value when using shadow to active load of action qualifier A/B control register on TBCTR=0 boundary", epwm1, "epwmCounterCompare_cmpB");

epwm2.$name                                       = "EPWM2_V";
epwm2.epwmTimebase_phaseEnable                    = true;
epwm2.epwmTimebase_counterMode                    = "EPWM_COUNTER_MODE_UP_DOWN";
epwm2.epwmTimebase_hsClockDiv                     = "EPWM_HSCLOCK_DIVIDER_1";
epwm2.epwmTimebase_emulationMode                  = "EPWM_EMULATION_FREE_RUN";
epwm2.epwmCounterCompare_enableShadowLoadModeCMPB = false;
epwm2.epwmCounterCompare_enableShadowLoadModeCMPC = false;
epwm2.epwmCounterCompare_enableShadowLoadModeCMPD = false;
epwm2.epwmTimebase_counterModeAfterSync           = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm2.hrpwm_syncSource                            = "HRPWM_PWMSYNC_SOURCE_ZERO";
epwm2.epwmTimebase_period                         = 625;
epwm2.epwm.$assign                                = "EPWM2";
epwm2.epwm.epwm_aPin.$assign                      = "GPIO2";
epwm2.epwm.epwm_bPin.$assign                      = "GPIO3";

epwm3.$name                             = "EPWM3_W";
epwm3.epwmTimebase_hsClockDiv           = "EPWM_HSCLOCK_DIVIDER_1";
epwm3.epwmTimebase_counterMode          = "EPWM_COUNTER_MODE_UP_DOWN";
epwm3.hrpwm_syncSource                  = "HRPWM_PWMSYNC_SOURCE_ZERO";
epwm3.epwmTimebase_counterModeAfterSync = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm3.epwmTimebase_emulationMode        = "EPWM_EMULATION_FREE_RUN";
epwm3.epwm.epwm_aPin.$assign            = "GPIO4";
epwm3.epwm.epwm_bPin.$assign            = "GPIO5";

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
epwm3.epwm.$suggestSolution = "EPWM3";
